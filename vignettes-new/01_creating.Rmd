---
title: "Creating and manipulating frequency tables"
author: "Michael Friendly"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
  fig_caption: yes
bibliography: ["vcd.bib", "vcdExtra.bib"]
vignette: >
  %\VignetteIndexEntry{Creating and manipulating frequency tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  fig.height = 6,
  fig.width = 7,
  fig.path = "fig/tut01-",
  dev = "png",
  comment = "##"
)

# Old Sweave options
# \SweaveOpts{engine=R,eps=TRUE,height=6,width=7,results=hide,fig=FALSE,echo=TRUE}
# \SweaveOpts{engine=R,height=6,width=7,results=hide,fig=FALSE,echo=TRUE}
# \SweaveOpts{prefix.string=fig/vcd-tut,eps=FALSE}
# \SweaveOpts{keep.source=TRUE}


# preload datasets ???
set.seed(1071)
library(vcd)
library(vcdExtra)
library(ggplot2)
data(HairEyeColor)
data(PreSex)
data(Arthritis, package="vcd")
art <- xtabs(~Treatment + Improved, data = Arthritis)
if(!file.exists("fig")) dir.create("fig")

```

R provides many methods for creating frequency and contingency tables. Several are
described below. In the examples below, we use some real examples and some anonymous
ones, where the variables `A`, `B`, and `C`  represent
categorical variables, and `X` represents an arbitrary R data object.

The first thing you need to know is that categorical data can be represented in
three different forms in R, and it is sometimes necessary to convert
from one form to another, for carrying out statistical tests, fitting models
or visualizing the results.  Once a data object exists in R, 
you can examine its complete structure with
the `str()` function, or view the names of its components with the
`names()` function.
 

* **case form** a data frame containing individual observations, with one or
more factors, used as the classifying variables. In case form, there may also
be numeric covariates. 
The total number of observations is `nrow(X)`, and the number of variables is `ncol(X)`.
  	
***Example***:

The `Arthritis` data is available in case form in the `vcd` package. 
There are two explanatory factors: `Treatment` and `Sex`. `Age`
is a numeric covariate, and `Improved` is the response--- an ordered factor,
with levels
`r paste(levels(Arthritis$Improved),collapse=' < ')`.  
Excluding `Age`, we would have
a $2 \times 2 \times 3$ contingency table for `Treatment`, `Sex` and `Improved`.
%`"None" < "Some" < "Marked"`.

```{r, case-form}
names(Arthritis)      # show the variables

str(Arthritis)        # show the structure

head(Arthritis,5)     # first 5 observations, same as Arthritis[1:5,] 
```
  
* **frequency form** a data frame containing one or more factors, and a frequency 
variable, often called `Freq` or `count`.  The total number of observations
is: `sum(X$Freq)`,  `sum(X[,"Freq"])` or some equivalent form.

The number of cells in the table is `nrow(X)`.

***Example***: 
For small frequency tables, it is often convenient to enter them in frequency form
using `expand.grid()` for the factors and `c()` to list the counts in a vector.
The example below, from [@vcd:Agresti:2002] gives results for the 1991 General Social Survey,
with respondents classified by sex and party identification.
```{r, frequency-form}
# Agresti (2002), table 3.11, p. 106
GSS <- data.frame(
  expand.grid(sex=c("female", "male"), 
              party=c("dem", "indep", "rep")),
  count=c(279,165,73,47,225,191))

GSS
names(GSS)
str(GSS)

sum(GSS$count)
```

* **table form**  a matrix, array or table object, whose elements are the frequencies
in an $n$-way table.  The variable names (factors) and their levels are given by
`dimnames(X)`. The total number of observations
is `sum(X)`.  The number of dimensions of the table is `length(dimnames(X))`,
and the table sizes are given by `sapply(dimnames(X), length)`.
  	
***Example***: 
The `HairEyeColor` is stored in table form in `vcd`.  
```{r, table-form1}
str(HairEyeColor)                      # show the structure

sum(HairEyeColor)                      # number of cases

sapply(dimnames(HairEyeColor), length) # table dimension sizes
```
***Example***: 
Enter frequencies in a matrix, and assign `dimnames`,
giving the variable names and category labels.  Note that, by default,
`matrix()` uses the elements supplied by *columns* in the
result, unless you specify `byrow=TRUE`.
```{r, table-form2}
# A 4 x 4 table  Agresti (2002, Table 2.8, p. 57) Job Satisfaction
JobSat <- matrix(c(1,2,1,0, 
                   3,3,6,1, 
                   10,10,14,9, 
                   6,7,12,11), 4, 4)

dimnames(JobSat) = list(
  income = c("< 15k", "15-25k", "25-40k", "> 40k"),
  satisfaction = c("VeryD", "LittleD", "ModerateS", "VeryS")
  )

JobSat
```

`JobSat` is a **matrix**, not an object of `class("table")`, and some functions
are happier with tables than matrices.
You can coerce it to a table with `as.table()`,
```{r, table-form3}
JobSat <- as.table(JobSat)
str(JobSat)
```

## Ordered factors and reordered tables {#sec:ordered-factors}

In table form, the values of the table factors are ordered by their position in the table.
Thus in the `JobSat` data, both `income` and `satisfaction` represent ordered
factors, and the *positions* of the values in the rows and columns reflects their
ordered nature.

Yet, for analysis, there are time when you need *numeric* values for the levels
of ordered factors in a table, e.g., to treat a factor as a quantitative variable.
In such cases, you can simply re-assign the `dimnames` attribute of the table
variables.  For example, here, we assign numeric values to `income` as the middle of their
ranges, and treat `satisfaction` as equally spaced with integer scores.

```{r, relevel, eval=FALSE}
dimnames(JobSat)$income <- c(7.5,20,32.5,60)
dimnames(JobSat)$satisfaction <- 1:4
```

For the  `HairEyeColor` data, hair color and eye color are ordered arbitrarily.
For visualizing the data using mosaic plots and other methods described below, it 
turns out to be more useful to assure that both hair color and eye color are
ordered from dark to light.
Hair colors are actually ordered this way already, and it is easiest to re-order
eye colors by indexing. Again `str()` is your friend.

```{r, reorder1}
HairEyeColor <- HairEyeColor[, c(1,3,4,2), ]
str(HairEyeColor)
```
This is also the order for both hair color and eye color shown in 
the result of a correspondence analysis (\figref{fig:ca-haireye}) below.

With data in  case form or frequency form, when you have ordered factors
represented with character values, you must ensure that they are treated
as ordered in R.
<!-- \footnote{In SAS, many procedures offer the option -->
<!-- 	`order = data | internal | formatted` to allow character values -->
<!-- 	to be ordered according to (a) their order in the data set, (b) -->
<!-- 	sorted internal value, or (c) sorted formatted representation -->
<!-- 	provided by a SAS format. -->
<!-- } -->

Imagine that the `Arthritis` data was read from a text file.  
By default the `Improved` will be ordered alphabetically:
`Marked`,
`None`,
`Some` --- not what we want.  In this case, the function
`ordered()` (and others) can be useful. 

```{r, reorder2, echo=TRUE, eval=FALSE}
Arthritis <- read.csv("arthritis.txt",header=TRUE)
Arthritis$Improved <- ordered(Arthritis$Improved, 
                              levels=c("None", "Some", "Marked")
                              )
```
The dataset `Arthritis` in the `vcd` package is a data.frame in this form
With this order of  `Improved`, the response in this data,
a mosaic display of `Treatment` and `Improved` (\figref{fig:arthritis}) shows a clearly
interpretable pattern.

The original version of `mosaic` in the `vcd` package required the input to be 
a contingency table in array form.

```{r Arthritis, height=6, width=7, fig.cap="Mosaic plot for the `Arthritis` data ..."}
data(Arthritis, package="vcd")
art <- xtabs(~Treatment + Improved, data = Arthritis)
mosaic(art, gp = shading_max, split_vertical = TRUE, main="Arthritis: [Treatment] [Improved]")
```


Finally, there are situations where, particularly for display purposes, you
want to re-order the *dimensions* of an $n$-way table, or change the
labels for the variables or levels.
This is easy when the data are in table form: `aperm()` permutes
the dimensions, and assigning to `names` and `dimnames`
changes variable names and level labels respectively.
We will use the following version of `UCBAdmissions` in
\secref{sec:mantel} below.
^[Changing `Admit` to `Admit?` might be useful for display purposes, but is
dangerous--- because it is then difficult to use that variable name in a model formula.
See \secref{sec:tips} for options `labeling_args` and `set_labels`to change variable and level names for displays in the `strucplot` framework.]

```{r, reorder3}
UCB <- aperm(UCBAdmissions, c(2, 1, 3))
dimnames(UCB)[[2]] <- c("Yes", "No")
names(dimnames(UCB)) <- c("Sex", "Admit?", "Department")

# display as a flattened table
stats::ftable(UCB)
```

## `structable()` {#sec:structable}

For 3-way and larger tables
the `structable()` function in `vcd` provides a convenient and flexible tabular display.
The variables assigned to the rows and columns of a two-way display can be specified
by a model formula.
```{r, structable}
structable(HairEyeColor)                   # show the table: default
structable(Hair+Sex ~ Eye, HairEyeColor)   # specify col ~ row variables
```
It also returns an object of class `"structable"` which may be plotted with 
`mosaic()` (not shown here).
```{r, structable1,eval=FALSE}
HSE < - structable(Hair+Sex ~ Eye, HairEyeColor)   # save structable object
mosaic(HSE)                                        # plot it
```

## `table()` and friends {#sec:table}

You  can  generate frequency  tables from factor variables  using the  `table()` function,  tables  of
proportions using  the `prop.table()` function,  and marginal  frequencies using
`margin.table()`.

For these examples, create some categorical vectors:
```{r, table-setup}
 n=500
 A <- factor(sample(c("a1","a2"), n, rep=TRUE))
 B <- factor(sample(c("b1","b2"), n, rep=TRUE))
 C <- factor(sample(c("c1","c2"), n, rep=TRUE))
 mydata <- data.frame(A,B,C)
```

These lines illustrate `table`-related functions:
```{r, table-ex1}
# 2-Way Frequency Table
attach(mydata)
mytable <- table(A,B)   # A will be rows, B will be columns
mytable                 # print table

margin.table(mytable, 1) # A frequencies (summed over B)
margin.table(mytable, 2) # B frequencies (summed over A)

prop.table(mytable)    # cell percentages
prop.table(mytable, 1) # row percentages
prop.table(mytable, 2) # column percentages
```

`table()` can  also  generate  multidimensional  tables  based  on  3  or  more
categorical variables. In  this case, you can use  the `ftable()`  or `structable()`
function to print the results more attractively.

```{r, table-ex2}
# 3-Way Frequency Table
mytable <- table(A, B, C)
ftable(mytable)
```

`table()`  ignores missing values by default. 
To include `NA` as a category in counts, include the
table option  `exclude=NULL` if  the variable  is a  vector. If  the variable is a
factor you  have to  create a  new factor  using \code{newfactor  <- factor(oldfactor,
exclude=NULL)}. 

## `xtabs()` {#sec:xtabs}

The `xtabs()` function allows you to create cross-tabulations of data using formula style input.
This typically works with case-form data supplied in a data frame or a matrix.
The result is a contingency table in array format, whose dimensions are determined by
the terms on the right side of the formula.

```{r, xtabs-ex1}
# 3-Way Frequency Table
mytable <- xtabs(~A+B+C, data=mydata)

ftable(mytable)    # print table
summary(mytable)   # chi-square test of indepedence
```

If a variable is included on the left side of the formula, it is assumed to be a
vector  of  frequencies  (useful if the data have already been tabulated in frequency form).

```{r, xtabs-ex2}
(GSStab <- xtabs(count ~ sex + party, data=GSS))
summary(GSStab)
```

<!-- ## Styles -->

<!-- The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows: -->

<!--     output:  -->
<!--       rmarkdown::html_vignette: -->
<!--         css: mystyles.css -->

<!-- ## Figures -->

<!-- The figure sizes have been customised so that you can easily put two images side-by-side.  -->

<!-- ```{r, fig.show='hold'} -->
<!-- plot(1:10) -->
<!-- plot(10:1) -->
<!-- ``` -->

<!-- You can enable figure captions by `fig_caption: yes` in YAML: -->

<!--     output: -->
<!--       rmarkdown::html_vignette: -->
<!--         fig_caption: yes -->

<!-- Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**. -->


# References

